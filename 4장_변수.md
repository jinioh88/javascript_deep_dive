# 내용정리
## 변수라 무엇인가? 왜 필요한가?
- 메모리는 데이터를 저장할 수 있는 메모리 셀의 집합이다. 
- 하나의 셀의 크기는 1바이트(8비트). 
- 각 셀은 고유의 주소를 갖는다. 
- 코드가 실행되기 이전에는 값이 저장되 메모리 주소를 알 수 없으며, 알려주지도 않는다.
- 따라서 메모리 주소를 통해 값에 직접 접근하려는 시도는 올바른 방법이 아니다. 
- 변수는 하나의 값을 저장하기 위해 확보하 메모리 공가 자체 또는 그 메모리 공가을 식별하기 위해 붙인 이름을 말한다. 

## 식별자
- 변수 이름을 식별자 라고도 한다. 
- 식별자는 어던 값이 저장되어 있는 메모리 주소를 기억해야 한다. 
- 식별자라는 용어는 변수 이름에만 국한해 사용하지 않는다. 변수, 함수, 클래스 등의 이름은 모두 식별자다. 
- 식별자는 네이밍 규칙을 준수해야 하며, 선언에 의해 자바스크립트 엔진에 식별자의 존재를 알ㄹ니다. 

## 변수 선언
- 자바스크립트 엔진은 변수 서언을 다음과 같은 2단계에 거쳐 수행
  - 선언 단계: 변수 이름을 등록해 자바스크립트 엔진에 변수의 존재를 알림
  - 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefinded를 할당해 초기화.
- 변수 이름은 어디에 등록되는가?
  - 변수 이름을 비롯한 모든 식별자는 실행 커텍스트에 등록.
  - 자바스크립트 엔진은 실행 컨텍스트를 통해 식별자와 스코프를 관리

## 변수 선언의 실행 시점과 변수 호이스팅
- 변수 선언은 소스코드가 런타임이 아니라 그 이전 단계에서 먼저 실행됨. 
- 한 주 ㄹ씩 순차적으로 실행하기 앞서 먼저 소스코드의 평가 과정을 거치면서 소스코드를 실행하기 위한 준비를 한다. 
- 소스코드 평과 과정에서 자바스크립트 엔진은 변수 선ㄴ언을 포함한 모든 선언문을 소스코드에서 찾아내 먼저 실행. 
- 소스코드 평가 과정이 끝나면 비로소 변수 선언을 포함한 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행.
- 이처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅이라 한다. 

## 값의 할당
- 변수 서언은 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점은 런타임에 실행됨. 

## 값의 재할당
- score 변수에 이저에 80에서 90으로 재할당하면, 이저 값 80이 저장되어 있는 메모리 공간을 지우고 새로운 메모리 공간을 확보해 그 메모리 공간에 숫자 90을 저장한다. 
- 사용되지 않는 불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동 해제된다. 

## 식별자 네이밍 규칙
- 일반적으로 변수나 함수의 이름에는 카멜케이스 사용, 생성자 함수, 클래스 이름에는 파스칼 케이스 사용. 

# 추가정리
🧠 1️⃣ 핵심 복습 문제

변수란 무엇이며, 왜 필요한가요?

식별자란 무엇이며, 변수 이름과 어떤 관계가 있나요?

변수 선언 시 자바스크립트 엔진은 어떤 단계를 거치나요?

변수 호이스팅이 발생하는 이유를 설명해보세요.

값의 할당과 선언은 실행 시점이 어떻게 다른가요?

변수 재할당 시 메모리에서 어떤 일이 일어나나요?

💻 2️⃣ 코드 실습 문제
🧩 문제 1. 변수 선언과 할당 시점 비교
``` js
console.log(score); // ?

var score = 80;
console.log(score); // ?

```
질문:
1️⃣ 첫 번째 console.log의 출력 결과는?
2️⃣ 호이스팅이 없었다면 어떤 에러가 발생했을까요?
3️⃣ 왜 이런 현상이 일어나는지 설명해보세요.

🧩 문제 2. 선언 단계와 초기화 단계 분리 실험
``` js
console.log(x); // ?
let x = 10;
console.log(x);
```
힌트:
let은 선언 단계와 초기화 단계가 분리되어 진행됩니다.
TDZ(Temporal Dead Zone) 때문에 선언 전에 참조하면 ReferenceError 발생.

🧩 문제 3. 변수 재할당 실험
``` js
let a = 10;
a = 20;

console.log(a); // ?
```
설명:
기존 메모리 공간을 덮어쓰는 게 아니라, 새로운 메모리 공간을 할당하고 식별자가 그 주소를 참조하도록 변경됩니다.
이전 값 10은 더 이상 참조되지 않으므로 GC(Garbage Collector) 대상이 됩니다.


💬 3️⃣ 프론트엔드 면접 포인트

질문 1: “변수 호이스팅이란 무엇이며, 왜 발생하나요?”
핵심 포인트:
자바스크립트 엔진이 실행 전 “소스코드 평가 단계”에서 변수 선언을 미리 처리하기 때문.
따라서 실제 선언문이 아래 있어도, 선언 자체는 위로 끌어올려진 것처럼 동작함.

예시:
``` js
console.log(a); // undefined
var a = 1;
```

질문 2: “var, let, const의 차이점은 무엇인가요?”
| 구분      | var                 | let    | const  |
| ------- | ------------------- | ------ | ------ |
| 스코프     | 함수 스코프              | 블록 스코프 | 블록 스코프 |
| 선언 전 참조 | `undefined` (호이스팅됨) | TDZ 오류 | TDZ 오류 |
| 재할당     | 가능                  | 가능     | 불가능    |
| 재선언     | 가능                  | 불가능    | 불가능    |

면접에서 주로 묻는 포인트: TDZ와 호이스팅의 관계, let이 등장한 이유.


질문 3: “재할당과 가비지 컬렉션의 관계를 설명해보세요.”

핵심 개념:
JS는 자동 메모리 관리 언어.
변수 재할당 시, 기존 값은 참조가 사라지고 GC가 해제 대상으로 인식.
개발자가 직접 해제할 수는 없음.
추가 질문 예시:
“React에서 상태(state)가 변경될 때, 메모리에서는 어떤 일이 일어날까요?”
→ 내부적으로는 새로운 객체 참조로 교체되어 이전 상태는 GC 대상이 됨.

🚀 4️⃣ 추가 학습 제안
주제	설명
🧠 실행 컨텍스트(13장)	변수의 선언, 초기화, 스코프 관리가 실제로 어떻게 처리되는지 깊이 이해할 수 있습니다.
🔍 TDZ (Temporal Dead Zone)	let, const의 안전한 설계 이유를 이해하기 위해 꼭 알아야 함.
📦 메모리 관리 구조	JS는 스택(Stack)과 힙(Heap)을 사용합니다. 스택에는 원시값, 힙에는 객체가 저장됩니다.
📗 실습 확장: 브라우저 콘솔에서 window 객체를 열어보고, var로 선언된 변수와 let으로 선언된 변수가 어떻게 다르게 등록되는지 비교해보세요.	



