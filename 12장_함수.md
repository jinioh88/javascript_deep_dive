# 내용정리
## 함수 리터럴
- 함수 리터를은 function 키워드, 함수 이름, 매개변수 목록, 함수 몸체로 구성
``` js
var f = function add(x, y) {
    return x+y;
};
```
- 함수는 호출할 수 있는 객체다. 

## 함수 정의
- 함수 선언문
``` js
function add(x, y) {
    return x+y;
};
```
- 함수 표현식
``` js
var add = function (x, y) {
    return x+y;
};
```
- Function 생성자 함수
``` js
var add = new Function('x', 'y', 'return x+y');
```
- 화살표 함수
``` js
var add = (x,y) => x+y;
```

### 함수 선언문
- 함수 선언문은 함수 이름을 생략할 수 없다
- 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다. 
- 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다. 

### 함수 표현식
- 함수 리터럴은 함수 이름을 생략할 수 있다. (익명함수)
- 함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적.

### 함수 생성 시점과 함수 호이스팅
``` js
// 함수 선언문
function add(x, y) { return x+y; }

// 함수 표현식
var sub = function (x, y) { return x-y;}
```
- 함수 선언문도 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행됨. 이후 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당함.
  - 즉, 런타임에는 이미 함수 객체가 생성되어 있고 함수 이름과 동일한 식별자에 할당까지 완료한 상태.
- 따라서 함수 선언문 이전에 함수를 참조할 수 있으며 호출할 수도 있다. (함수 호이스팅)
- 하지만 var 키워드로 선언된 변수는 undefinded로 초기화되고, 함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화된다. 
- 따라서 var 키워드를 사용한 변수 선언문 이전에 변수를 참조하면 변수 호이스팅에 의해 undefinded로 평가되지만 함수 선언문으로 정의한 함수를 함수 선언문 이전에 호출하면 함수 호치스팅에 의해 호출이 가능.
- 변수 선언은 런타임 이전에 실행되어 undefinded로 초기화 되지만 변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다. 
- 따라서 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생.
- 따라서 함수 표현식으로 정의한 함수는 반드시 함수 표현식 이후에 참조 또는 호출해야 함.
- 함수 호이스팅 문제로 함수 선언문 대신 함수 표현식을 사용할 것을 권장

## 함수 호출
### 매개변수
- 인수가 부족해 인수가 할당죄지 않은 매개변수의 값은 undefined다. 
- 모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관된다. 
- arguments 객체는 함수를 정의할 때 매개 변수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용.

### 인수확인
- 자바스크립트의 경우 함수를 정의할 때 적절한 인수가 전달되었는지 확인할 필요가 있다.
``` js
function add(x, y) {
    if (typeof x !== 'number' || typeof y !== 'number) {
        throw new TypeError('인수는 숫자여야함');
    }
    return x + y;
}
```
- arguments 객체를 통해 인수 개수를 확인 할 수도 있다. 또는 인수가 전달되지 않은 경우 단축평가를 사용해 매개변수에 기본값을 할당하는 방법도 있다.
``` js
function add (a, b, c) {
    a = a || 0;
    b = b || 0;
    c = c || 0;
    return a + b + c;
}
```
- ES6에 도입된 매개변수 기본값을 사용하면 함수 내에서 수행하던 인수 체크 및 초기화를 간소화 할 수 있다
``` js
function add (a = 0, b = 0, c = 0) {
    return a+b+c;
}
```

### 매개변수의 최대 개수
- 함수의 매개변수는 코드를 이해하는 데 방해되는 요소이므로 이상적인 매개변수 개수는 0개며 적을수록 좋다.
- 이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다.
  - 매개변수의 개수가 많다는 것은 함수가 여러가지 일을 한다는 증거
- 따라서 최대 3개 이상을 넘기지 않는 것을 권장.
- 그 이상일 경우 객체를 인수로 전달하는 것이 유리

### 반환문
- 반환문을 생략하면 함수는 함수 몸체의 마지막 문까지 실행한 후 암묵적으로 undefinded를 반환.

## 참조에 의한 전달과 외부 상태의 변경
- 함수가 외부 상태를 변경하면 상태 변화를 추적하기 어려워짐. 
- 객체의 변경을 추적하려면 옵저버 패턴 등을 통해 객체를 참조를 공유하는 모든 이들에게 변경 사실을 통지하고 이에 대처하는 추가 대응이 필요.
- 이 문제의 해결 방법 중 하나는 객체를 불변 객체로 만들어 사용하는 것.
- 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수를 순수함수라 함.
- 순수 함수를 통해 부수효과를 최대한 억제하여 오류를 피하고 프로그램의 안전성을 높이려는 프로그래밍 패러다임을 함수형 프로그래밍이라 함.

## 다양한 함수의 형태
### 즉시 실행 함수
- 함수의 정의와 동시에 즉시 실행되는 함수.
- 한번만 호출되고 다시 호출할 수 없음.
- 반드시 그룹 연산자 '(...)'로 감싸야함.
``` js
(function () {
    var a = 3;
    return a;
}());
```
- 즉시실행 함수는 익명 함수를 사용하는 것이 일반적.
``` js
var res = (function () {
    var a = 3;
    return a;
}());

res = (function (a, b) {
    return a + b;
}(3, 5));
```

### 재귀 함수
- 탈출 조건을 반드시 만들어야 함.
- 무한 반복 위험이 있어서 반복문을 사용하는 것보다 재귀 함수를 사용하는 편이 더 직관적으로 이해하기 쉬울 때만 한정적으로 사용하는 것이 바람직.

### 중첩 함수
- 함수 내부에 정의된 함수를 중첩 함수 또는 내부 함수라 함.
- 중첩함수를 포함하는 함수를 외부 함수라 부름
- 일반적으로 중첩 함수는 자신을 포함하는 외부 함수를 돕는 헬퍼 함수의 역할을 함.

### 콜백 함수
``` js
function repeat1(n) {
    for (var i = 0; i < n; i++) console.log(i);
}

function repeat2(n) {
    for (var i = 0; i < n; i++) {
        if (i%2) 
            console.log(i);
    }
}
```
- 위의 두 함수는 반복하는 일은 변하지 않고 공통적으로 수행하지만 반복하면서 하는 일은 내용은 다르지 않다. 
- 함수의 일부분만이 다르기 때문에 매번 함수를 새롭게 정의해야 한다.
- 이 문제는 함수를 합성하는 것으로 해결가능.
- 함수의 변하지 않는 공통 로직은 미리 정의해두고, 경우에 따라 변경되는 로직은 추상화해 함수 외부에서 내부로 전달하는 것
``` js
function repat(n, f) {
    for (var i = 0; i < n; i++) {
        f (i);
    }
}

var logAll = function (i) {
    console.log(i);
}

repat(5, logAll);

var logOdd = function (i) {
    if (i%2) 
        console.log(i);
}
repat(5, logOdd);
```
- 위 repat 함순느 경우에 따라 변경되는 일을 함수 f로 수항화했고 이를 외부에서 전달 받음. 
- repeat 함수는 더 이상 내부 로직에 강력히 의존하지 않고 외부에서 로직의 일부분을 함수로 전달받아 수행하므로 더욱 유연한 구조를 갖게 됨.
- 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백함수라고 하며, 매개변수를 통해 함수의 외부에서 콜백함수를 전달받은 함수를 고차 함수라고 한다. 
- 고차 함수는 콜백 함수를 자신의 일부분으로 합성한다.
- 고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해 호출한다. 
- 콜백 함수는 고차 함수에 의해 호출되며 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다. 
- 콜백 함수가 고차 함수 내부에만 호출된다면 콜백 함수를 익명 함수 리터럴로 정의하면서 곧바로 고차 함수에 전달하는 것이 일반적.
``` js
repat(5, function(i) {
    if (i%2) 
        console.log(i);
});
```
- 이때 콜백 함수로서 전달된 함수 리터럴은 고차 함수가 호출될 때마다 평가되어 함수 객체를 생성.
- 따라서 콜백 함수를 전달받은 함수가 자주 호출된다면 함수 외부에 콜백 함수를 정의한 후 함수 참조를 고차 함수에 전달하는 것이 효율적.
- 콜백 함수는 비동기 처리에도 활용되는 중요한 패턴이다.
- 배열 고차 함수에서도 사용된다.

### 순수 함수와 비순수 함수
- 외부 상태에 부수 효과가 없는 함수를 순수 함수라 함.
- 순수 함수는 일반적으로 최소 하나 이상의 인수를 전달 받는다. 인수를 받지 않으면 언제나 동일한 값ㅇ르 반환하므로 결국 상수와 마찬가지. 
- 순수함수는 인수를 변경하지 않는 것이 기본.
- 순수 함수의 또 하나의 특징은 함수의 외부 상태를 변경하지 않는다는 것.
- 함수 외부 상태ㅐ의 변경을 지양하는 순수 함수를 사용하는 것이 좋다.
``` js
var count = 0;

// 순수 함수. 동일한 인수가 전달되면 언제나 동일한 값을 반환
function increase(n) {
    return ++ n;
}

// 순수 함수가 반환한 결과값을 변수에 재할당해 상태를 변경
count = increase(count);
```

# 추가정리