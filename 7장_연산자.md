# 내용정리
## 삼항 조건 연산자
- 조건에 따라 어떤 값을 결정해야 한다면 if ... else 문보다 삼항 조건 연산자 표현식을 사용하는 편이 유리
- 조건에 따라 수행해야 할 문이 하나가 아니라 여러개라면 if ...else 문의 가독성이 더 좋음.

## typeof 연산자
- typeof 연산자로 null 값을 연산하면 'object'를 반환한다는 데 주의하자.
- 값이 null 인지 확인할 때는 typeof 연산자를 사용하지 말고 '==='를 사용하자
- 선언하지 않은 식별자를 typeof로 하면 ReferenceError가 아닌 undefined를 반환.

## 지수 연산자
- ES7에 도입. 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제롭하여 숫자 값을 반환
- 지수 연산자가 도입 되기 이전에는 Math.pow() 사용.
- 음수를 거듭제곱의 밑으로 사용해 계산하려면 괄호로 묶어야 함.
  - (-5) ** 2;


# 추가정리
🧠 1️⃣ 핵심 복습 문제

삼항 조건 연산자와 if문은 언제 각각 사용하는 것이 적절한가요?

typeof null의 반환값이 'object'인 이유는 무엇인가요?

typeof 연산자 사용 시 선언되지 않은 변수에 대해 어떤 값을 반환하나요?

지수 연산자(**)는 어떤 동작을 하며, 기존 Math.pow()와 어떤 차이가 있나요?

💻 2️⃣ 코드 실습 문제
🧩 문제 1. 삼항 연산자 실습
``` js
const age = 20;
const message = age >= 18 ? "성인입니다." : "미성년자입니다.";
console.log(message);
```
질문:
위 코드에서 if...else로 바꿨을 때 가독성은 어떻게 달라질까요?
조건에 따라 “값”을 결정할 때는 삼항 연산자,
“문(로직)”을 실행할 때는 if문이 더 적절합니다.

🧩 문제 2. typeof 연산자와 null 비교
``` jsconsole.log(typeof null);        // ?
console.log(typeof undefined);   // ?
console.log(typeof undeclared);  // ?
```
💡 정답

typeof null → "object" (JS 설계상 버그, 역사적 유산)

typeof undefined → "undefined"

typeof undeclared → "undefined" (ReferenceError가 발생하지 않음!)

✅ null 체크는 항상 엄격 비교(===)로 하세요:
``` js
if (value === null) console.log("값이 null입니다.");
```

🧩 문제 3. 지수 연산자 실습
``` js
console.log(2 ** 3);   // ?
console.log((-5) ** 2); // ?
console.log(-5 ** 2);   // ?
```
💡 -5 ** 2는 문법 오류(SyntaxError)!
이유: 지수 연산자의 우선순위가 단항 연산자보다 높기 때문.
따라서 음수를 밑으로 사용할 때는 반드시 괄호로 묶어야 합니다.

🧩 문제 4. 실무형 예제 – 점수 판정기
``` js
const score = 85;
const grade = 
  score >= 90 ? "A" :
  score >= 80 ? "B" :
  score >= 70 ? "C" :
  "F";

console.log(`당신의 점수는 ${score}, 등급은 ${grade}`);
```
삼항 연산자를 중첩할 때는 정렬을 깔끔하게 유지해야 합니다.
너무 복잡하다면 if...else if 문으로 전환하는 게 더 낫습니다.

💬 3️⃣ 프론트엔드 면접 포인트

질문 1: “삼항 연산자와 if문은 어떤 상황에서 각각 사용해야 하나요?”

핵심 포인트:

삼항 연산자: 값(value)을 선택해야 하는 상황

if문: 명령(statement) 을 수행해야 하는 상황

예시:
``` js
// 삼항: 값 선택
const label = isAdmin ? "관리자" : "사용자";

// if문: 로직 수행
if (isAdmin) {
  showAdminPanel();
} else {
  redirectHome();
}
```

질문 2: “typeof null이 object인 이유는 뭔가요?”

답변 포인트:

JS 초기 구현 시, 값이 32비트 단위로 저장되었는데,
하위 비트가 0인 경우 object로 분류하는 설계로 인해 생긴 버그.

역사적 이유로 표준에서 수정되지 않고 그대로 유지됨.

면접 팁:
이 질문은 “JS의 설계적 한계나 역사적 이유를 알고 있는가?”를 보는 문제예요.

질문 3: “typeof undeclaredVar의 결과가 왜 undefined인가요?”

핵심 포인트:

typeof는 ReferenceError를 발생시키지 않음.

변수가 선언되지 않아도 "undefined" 반환.

ES6 이후 전역 스코프에서 안전하게 타입 확인할 수 있게 설계됨.

활용 예시:
``` js
if (typeof window === "undefined") {
  console.log("Node.js 환경입니다");
}
```

질문 4: “지수 연산자 우선순위 문제로 발생할 수 있는 오류는?”

답변:

단항 부정(-)보다 지수 연산(**)의 우선순위가 높기 때문에
-5 ** 2는 SyntaxError 발생.

올바른 작성법: (-5) ** 2

🚀 4️⃣ 추가 학습 제안
주제	설명
🧠 연산자 우선순위표	MDN의 Operator Precedence Table
 꼭 한 번 읽어보세요.
🔍 타입 변환과 typeof	null, undefined, NaN, [], {} 등 다양한 값의 typeof 결과를 표로 정리해보세요.
⚙️ 삼항 연산자 실전 패턴	React 컴포넌트 렌더링 조건문에서 삼항 연산자를 가독성 있게 사용하는 연습 (예: {isLogin ? <Dashboard/> : <LoginPage/>})
🔢 ES7 이후 연산자들	지수 연산자(**) 외에도 ES2020의 optional chaining(?.), nullish coalescing(??) 등도 함께 익히면 좋습니다.

