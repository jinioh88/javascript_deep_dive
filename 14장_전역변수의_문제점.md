# 내용정리
## 변수의 생명 주기
### 지역 변수의 생명 주기
- 지역 변수의 생명 주기는 함수의 생명 주기와 일치
- 함수 내부에서 선언된 지역 변수는 함수가 생성한 스코프에 등록된다. 
- 일반적으로 함수가 종료하면 함수가 생성한 스코프도 소멸.
``` js
var x = 'global';

function foo() {
    console.log(x); // 1) undefinded
    var x = 'local';
}

foo();
console.log(x);
```
- foo 내부에서 선언된 지역변수 x는 1의 시점에 이미 선언되었고 undefinded로 초기화되어 있음
- 이처럼 호이스팅은 스코프를 단위로 동작. 

### 전역 변수의 생명 주기
- var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 된다. 
- 전역객체
  - 전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다 먼저 생성되는 특수한 객체. 
- 브라우저 환경에서 전역객체는 window으므로 브라우저 환경에서 var 키워드로 선언한 전역 변수는 window의 프로퍼티다. 
- 즉, var 키워드로 선언한 전역 변수의 생명주기는 전역 객체의 생명주기와 일치.

## 전역 변수의 문제점
-  암묵적 결합
  - 변수의 유효범위가 커져 코드 가독성이 나빠지고 위험성 증가
-  긴 생명주기
- 스코프 체인 상에서 종점에 존재
  - 이는 변수를 검색할 때 전역 변수가 가장 마지막에 검색된다는 말
  - 즉, 전역 변수의 검색 속도가 가장 느림.
- 네임스페이스 오염'
  - 자바스크립트는 파일이 분리되어 있다 해도 하나의 전역 스코프를 공유한다는 것.

## 전역 변수의 사용을 억제하는 방법
### 즉시 실행 함수
- 모든 코드를 즉시 실행함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다. 

### 네임스페이스 객체
- 전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법
``` js
var MYAPP = {}; // 전역 네임스페이스 객체
MYAPP.name = 'oh';
console.log(MYAPP.name);
```
- 네임 스페이스 객체 자체가 전역 변수에 할당되므로 그다지 유용해보이진 않음

### 모듈 패턴
- 모듈 패턴은 클래스를 모방해 관련 있는 변수와 함수를 모아 즉시 실행함수로 감싸 하나의 모듈을 만든다.
- 모듈 패턴은 전역 네임스페이스의 오염을 막는 기능은 물론 한정적이기는 하지만 정보 은닉을 구현하기 위해 사용.
``` js
var Counter = (function() {
    var num = 0; // private 변수

    // 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환
    return {
        increase() {
            return ++num;
        },
        decrease() {
            return --num;
        };
    };
}());

console.log(Counter.num); // undefinded. private 변수는 외부로 노출 X
console.log(Coutner.increase); // 1
```

### ES6 모듈
- ES 모듈은 파일 자체의 독자적인 모듈 스코프를 제공
- 따라서 모듈 내에서 var 키워드로 선언한 변수는 더이상 전역 변수가 아니며 window 객체의 프로퍼티도 아님.
- script 태그에 type='modue' 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로 동작
- 파일 확장자는 mjs 권장
``` html
<script type='module' src='lib.mjs'></script> 
```
- 아직까지는 ES6 모듈 기능보다는 Webpack 등의 모듈 번들러를 사용하는 것이 일반적

# 추가정리